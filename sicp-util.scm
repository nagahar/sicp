;; sicp1章2章で定義された手続き
(use slib)
(require 'trace)
(define (square x)
  (* x x))
(define (average x y)
  (/ (+ x y) 2))
(define (runtime)
  (use srfi-11)
  ;; sys-gettimeofdayの１番目の値がaに、2番目の値がbに格納され、計算結果が戻される
  (let-values (((a b) (sys-gettimeofday)))
	(+ (* a 1000000) b)))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
	((divides? test-divisor n) test-divisor)
	(else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
(define (square x)
  (* x x))
(define (enumerate-interval low high)
  (if (> low high)
	'()
	(cons low (enumerate-interval (+ low 1) high))))
(define (enumerate-tree tree)
  (cond ((null? tree) '())
	((not (pair? tree)) (list tree))
	(else (append (enumerate-tree (car tree))
				  (enumerate-tree (cdr tree))))))
(define (accumulate op initial sequence)
  (if (null? sequence)
	initial
	(op (car sequence)
		(accumulate op initial (cdr sequence)))))
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
	'()
	(cons (accumulate op init (map car seqs))
		  (accumulate-n op init (map cdr seqs)))))
(define (filter predicate sequence)
  (cond ((null? sequence) '())
	((predicate (car sequence))
	 (cons (car sequence)
		   (filter predicate (cdr sequence))))
	(else (filter predicate (cdr sequence)))))
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(define (make-table)
  (let ((local-table (list '*table*)))
	(define (lookup key-1 key-2)
	  (let ((subtable (assoc key-1 (cdr local-table))))
		(if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
			(if record
			  (cdr record)
			  #f))
		  #f)))
	(define (insert! key-1 key-2 value)
	  (let ((subtable (assoc key-1 (cdr local-table))))
		(if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
			(if record
			  (set-cdr! record value)
			  (set-cdr! subtable
						(cons (cons key-2 value)
							  (cdr subtable)))))
		  (set-cdr! local-table
					(cons (list key-1
								(cons key-2 value))
						  (cdr local-table)))))
	  'ok)
	(define (dispatch m)
	  (cond ((eq? m 'lookup-proc) lookup)
		((eq? m 'insert-proc!) insert!)
		(else (error "Unknown operation -- TABLE" m))))
	dispatch))
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(define coercion-table (make-table))
(define get-coercion (coercion-table 'lookup-proc))
(define put-coercion (coercion-table 'insert-proc!))

(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (attach-tag type-tag contents)
  (if (eq? 'scheme-number type-tag)
	contents
	(cons type-tag contents)))
(define (type-tag datum)
  (cond ((pair? datum) (car datum))
	((number? datum) 'scheme-number)
	(error "Bad tagged datum -- TYPE-TAG" datum)))
(define (contents datum)
  (cond ((pair? datum) (cdr datum))
	((number? datum) datum)
	(error "Bad tagged datum -- CONTENTS" datum)))
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))
(define (xsquare x) (apply-generic 'xsquare x))
(define (xsqrt x) (apply-generic 'xsqrt x))
(define (xcos x) (apply-generic 'xcos x))
(define (xsin x) (apply-generic 'xsin x))
(define (xatan x y) (apply-generic 'xatan x y))
(define (raise x) (apply-generic 'raise x))
(define (inv x) (apply-generic 'inv x))
(define (greatest-common-divisor x y) (apply-generic 'greatest-common-divisor x y))
(define (reduce x y) (apply-generic 'reduce x y))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
	(let ((proc (get op type-tags)))
	  (if proc
		(apply proc (map contents args))
		(if (= (length args) 2)
		  (let ((type1 (car type-tags))
				(type2 (cadr type-tags))
				(a1 (car args))
				(a2 (cadr args)))
			(if (eq? type1 type2)
			  (error "No method for these types"
					 (list op type-tags))
			  (let ((t1->t2 (get-coercion type1 type2))
					(t2->t1 (get-coercion type2 type1)))
				(cond (t1->t2
						(apply-generic op (t1->t2 a1) a2))
				  (t2->t1
					(apply-generic op a1 (t2->t1 a2)))
				  (else
					(error "No method for these types"
						   (list op type-tags)))))))
		  (error "No method for these types"
				 (list op type-tags)))))))

(define (install-scheme-number-package)
  (define (reduce-integers n d)
	(let ((g (gcd n d)))
	  (list (/ n g) (/ d g))))
  (define (tag x)
	(attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
	   (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
	   (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
	   (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
	   (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
	   (lambda (x) (tag x)))
  (put 'equ? '(scheme-number scheme-number)
	   (lambda (x y) (= x y)))
  (put '=zero? '(scheme-number)
	   (lambda (x) (zero? x)))
  (put 'inv '(scheme-number)
	   (lambda (x) (tag (- x))))
  (put 'greatest-common-divisor '(scheme-number scheme-number)
	   (lambda (x y) (gcd x y)))
  (put 'reduce '(scheme-number scheme-number)
	   (lambda (x y) (reduce-integers x y)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-integer-package)
  (define (integer->rational x)
	(make-rational x 1))
  (define (tag x)
	(attach-tag 'integer x))
  (put 'add '(integer integer)
	   (lambda (x y) (tag (+ x y))))
  (put 'sub '(integer integer)
	   (lambda (x y) (tag (- x y))))
  (put 'mul '(integer integer)
	   (lambda (x y) (tag (* x y))))
  (put 'div '(integer integer)
	   (lambda (x y) (tag (/ x y))))
  (put 'make 'integer
	   (lambda (x) (tag x)))
  (put 'equ? '(integer integer)
	   (lambda (x y) (= x y)))
  (put '=zero? '(integer)
	   (lambda (x) (zero? x)))
  (put 'raise '(integer)
	   (lambda (x) (integer->rational x)))
  (put 'xsquare '(integer)
	   (lambda (x) (tag (square x))))
  (put 'xsqrt '(integer)
	   (lambda (x) (tag (round (sqrt x)))))
  (put 'xcos '(integer)
	   (lambda (x) (tag (round (cos x)))))
  (put 'xsin '(integer)
	   (lambda (x) (tag (round (sin x)))))
  (put 'xatan '(integer integer)
	   (lambda (x y) (tag (round (atan x y)))))
  (put 'inv '(integer)
	   (lambda (x) (tag (- x))))
  (put-coercion 'integer 'rational integer->rational)
  'done)
(define (make-integer n)
  ((get 'make 'integer) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
	(let ((reduced (reduce n d)))
	  (cons (car reduced) (cadr reduced))))
  (define (add-rat x y)
	(make-rat (add (mul (numer x) (denom y))
				   (mul (numer y) (denom x)))
			  (mul (denom x) (denom y))))
  (define (sub-rat x y)
	(make-rat (sub (mul (numer x) (denom y))
				   (mul (numer y) (denom x)))
			  (mul (denom x) (denom y))))
  (define (mul-rat x y)
	(make-rat (mul (numer x) (numer y))
			  (mul (denom x) (denom y))))
  (define (div-rat x y)
	(make-rat (mul (numer x) (denom y))
			  (mul (denom x) (numer y))))
  (define (sin-rat x)
	(make-rat (round (sin (div (numer x) (denom x))))
			  1))
  (define (cos-rat x)
	(make-rat (round (cos (div (numer x) (denom x))))
			  1))
  (define (sqrt-rat x)
	(make-rat (round (sqrt (div (numer x) (denom x))))
			  1))
  (define (atan-rat x y)
	(make-rat (round (atan (div (numer x) (denom x)) (div (numer y) (denom y))))
			  1))
  (define (square-rat x)
	(mul-rat x x))
  (define (rational->real x)
	(make-real (div (numer x) (denom x))))
  (define (rational->integer x)
	(make-integer (round (div (numer x) (denom x)))))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
	   (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
	   (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
	   (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
	   (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
	   (lambda (n d) (tag (make-rat n d))))
  (put 'equ? '(rational rational)
	   (lambda (x y) (and (equ? (numer x) (numer y))
					   (equ? (denom x) (denom y)))))
  (put '=zero? '(rational)
	   (lambda (x) (zero? (numer x))))
  (put 'raise '(rational)
	   (lambda (x) (rational->real x)))
  (put 'project '(rational)
	   (lambda (x) (rational->integer x)))
  (put 'xsin '(rational)
	   (lambda (x) (tag (sin-rat x))))
  (put 'xcos '(rational)
	   (lambda (x) (tag (cos-rat x))))
  (put 'xsqrt '(rational)
	   (lambda (x) (tag (sqrt-rat x))))
  (put 'xatan '(rational rational)
	   (lambda (x y) (tag (atan-rat x y))))
  (put 'xsquare '(rational)
	   (lambda (x) (tag (square-rat x))))
  (put 'inv '(rational)
	   (lambda (x) (tag (make-rat (inv (numer x)) (denom x)))))
  (put-coercion 'rational 'real rational->real)
  (put-coercion 'rational 'integer rational->integer)
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-real-package)
  (define (tag x)
	(attach-tag 'real x)) 
  (define (real->complex x)
	(make-complex-from-real-imag (make-sheme-number (round x)) (make-scheme-number 0)))
  (define (real->rational x)
	(make-rational (round x) 1))
  (put '=zero? '(real)
	   (lambda (x) (zero? x)))
  (put 'equ? '(real real)
	   (lambda (x y) (= x y)))
  (put 'add '(real real)
	   (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real)
	   (lambda (x y) (tag (- x y))))
  (put 'mul '(real real)
	   (lambda (x y) (tag (* x y))))
  (put 'div '(real real)
	   (lambda (x y) (tag (/ x y))))
  (put 'exp '(real real)
	   (lambda (x y) (tag (expt x y))))
  (put 'make 'real
	   (lambda (x) (tag x)))
  (put 'raise '(real)
	   (lambda (x) (real->complex x)))
  (put 'project '(real)
	   (lambda (x) (real->rational x)))
  (put 'inv '(real)
	   (lambda (x) (tag (- x))))
  (put-coercion 'real 'complex real->complex)
  (put-coercion 'real 'rational real->rational)
  'done)
(define (make-real n)
  ((get 'make 'real) n)) 

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
	(xsqrt (add (xsquare (real-part z))
				(xsquare (imag-part z)))))
  (define (angle z)
	(xatan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
	(cons (mul r (xcos a)) (mul r (xsin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
	   (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
	   (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
	(mul (magnitude z) (xcos (angle z))))
  (define (imag-part z)
	(mul (magnitude z) (xsin (angle z))))
  (define (make-from-real-imag x y) 
	(cons (xsqrt (add (xsquare x) (xsquare y)))
		  (xatan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
	   (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
	   (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
	((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
	((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
	(make-from-real-imag (add (real-part z1) (real-part z2))
						 (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
	(make-from-real-imag (sub (real-part z1) (real-part z2))
						 (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
	(make-from-mag-ang (mul (magnitude z1) (magnitude z2))
					   (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
	(make-from-mag-ang (div (magnitude z1) (magnitude z2))
					   (sub (angle z1) (angle z2))))
  ;;;(define (complex->real z)
  ;;;(make-real (real-part z)))
  (define (complex->real z)
	(real-part z))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
	   (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
	   (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
	   (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
	   (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
	   (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
	   (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'equ? '(complex complex)
	   (lambda (z1 z2) (and (equ? (magnitude z1) (magnitude z2))
						 (equ? (angle z1) (angle z2)))))
  (put '=zero? '(complex)
	   (lambda (z) (=zero? (magnitude z))))
  (put 'project '(complex)
	   (lambda (z) (complex->real z)))
  (put 'inv '(complex)
	   (lambda (x) (tag (make-from-real-imag (inv (real-part x))
											 (inv (imag-part x))))))
  (put-coercion 'complex 'real complex->real)
  'done)
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
(install-scheme-number-package)
(install-integer-package)
(install-rational-package)
(install-real-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)

(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
	(cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ;; representation of terms and term lists
  (define (add-terms L1 L2)
	(cond ((empty-termlist? L1) L2)
	  ((empty-termlist? L2) L1)
	  (else
		(let ((t1 (first-term L1)) (t2 (first-term L2)))
		  (cond ((> (order t1) (order t2))
				 (adjoin-term
				   t1 (add-terms (rest-terms L1) L2)))
			((< (order t1) (order t2))
			 (adjoin-term
			   t2 (add-terms L1 (rest-terms L2))))
			(else
			  (adjoin-term
				(make-term (order t1)
						   (add (coeff t1) (coeff t2)))
				(add-terms (rest-terms L1)
						   (rest-terms L2)))))))))
  (define (mul-terms L1 L2)
	(if (empty-termlist? L1)
	  (the-empty-termlist)
	  (add-terms (mul-term-by-all-terms (first-term L1) L2)
				 (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
	(if (empty-termlist? L)
	  (the-empty-termlist)
	  (let ((t2 (first-term L)))
		(adjoin-term
		  (make-term (+ (order t1) (order t2))
					 (mul (coeff t1) (coeff t2)))
		  (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (sub-terms L1 L2)
	(add-terms L1 (inv-terms L2)))
  (define (div-terms L1 L2)
	(if (empty-termlist? L1)
	  (list (the-empty-termlist) (the-empty-termlist))
	  (let ((t1 (first-term L1))
			(t2 (first-term L2)))
		(if (> (order t2) (order t1))
		  (list (the-empty-termlist) L1)
		  (let ((new-c (div (coeff t1) (coeff t2)))
				(new-o (- (order t1) (order t2))))
			(let ((rest-of-result
					(div-terms
					  (sub-terms L1 (mul-term-by-all-terms (make-term new-o new-c) L2))
					  L2)))
			  (list (cons (make-term new-o new-c) (car rest-of-result))
					(cadr rest-of-result))))))))
  (define (adjoin-term term term-list)
	(if (=zero? (coeff term))
	  term-list
	  (cons term term-list)))
  (define (inv-terms L)
	(if (empty-termlist? L)
	  (the-empty-termlist)
	  (let ((t (first-term L)))
		(adjoin-term
		  (make-term (order t)
					 (inv (coeff t)))
		  (inv-terms (rest-terms L))))))
  (define (remainder-terms L1 L2)
	(let ((result (div-terms L1 L2)))
	  (cadr result)))
  (define (gcd-terms L1 L2)
	(if (empty-termlist? L2)
	  (let ((gcdcoeff (apply gcd (map coeff L1))))
		(car (div-terms L1
						(adjoin-term 
						  (make-term 0 gcdcoeff) 
						  (the-empty-termlist)))))
	  (gcd-terms L2 (pseudoremainder-terms L1 L2))))

  (define (reduce-terms n d)
	(let ((g (gcd-terms n d)))
	  (define (reduce-inner itf)
		(let ((result (map (lambda (x) (car (div-terms (mul-term-by-all-terms (make-term 0 itf) x) g)))
						   (list n d))))
		  (let ((gcdcoeff (apply gcd (append (map coeff n)
											 (map coeff d)))))
			(map (lambda (x) (car (div-terms x (adjoin-term
												 (make-term 0 gcdcoeff)
												 (the-empty-termlist)))))
				 result))))
	  (let ((order-n (order (first-term n)))
			(order-d (order (first-term d))))
		(cond ((>= order-n order-d)
			   (reduce-inner (integerizing-factor n g)))
		  ((< order-n order-d)
		   (reduce-inner (integerizing-factor d g)))))))

  (define (pseudoremainder-terms L1 L2)
	(let ((itf (integerizing-factor L1 L2)))
	  (let ((result (div-terms (mul-term-by-all-terms (make-term 0 itf) L1) L2)))
		(cadr result))))
  (define (integerizing-factor L1 L2)
	(let ((o1 (order (first-term L1)))
		  (o2 (order (first-term L2)))
		  (c  (coeff (first-term L2))))
	  (expt c (add (sub o1 o2) 1))))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
  (define (zero-term? term)
	(or (empty-termlist? term)
	  (and (=zero? (coeff (first-term term)))
		(zero-term? (rest-terms term)))))

  (define (add-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
				 (add-terms (term-list p1)
							(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
			 (list p1 p2))))
  (define (mul-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
				 (mul-terms (term-list p1)
							(term-list p2)))
	  (error "Polys not in same var -- MUL-POLY"
			 (list p1 p2))))
  (define (div-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
				 (div-terms (term-list p1)
							(term-list p2)))
	  (error "Polys not in same var -- DIV-POLY"
			 (list p1 p2))))
  (define (inv-poly p)
	(make-poly (variable p) (inv-terms (term-list p))))
  (define (equ? p1 p2)
	(use srfi-1)
	(and (same-variable? (variable p1) (variable p2))
	  (list= (term-list p1) (term-list p2))))
  (define (gcd-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
				 (gcd-terms (term-list p1)
							(term-list p2)))
	  (error "Polys not in same var -- GCD-POLY"
			 (list p1 p2))))
  (define (reduce-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	  (map (lambda (x) (make-polynomial (variable p1) x))
		   (reduce-terms (term-list p1)
						 (term-list p2)))
	  (error "Polys not in same var -- REDUCE-POLY"
			 (list p1 p2))))
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) 
	   (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) 
	   (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial)
	   (lambda (p1 p2) (tag (add-poly p1 (inv-poly p2)))))
  (put 'div '(polynomial polynomial)
	   (lambda (p1 p2) (tag (div-poly p1 p2))))
  (put 'make 'polynomial
	   (lambda (var terms) (tag (make-poly var terms))))
  (put '=zero? '(polynomial)
	   (lambda (p) (zero-term? (term-list p))))
  (put 'inv '(polynomial)
	   (lambda (p) (tag (inv-poly p))))
  (put 'equ? '(polynomial polynomial)
	   (lambda (p1 p2) (equ? p1 p2)))
  (put 'greatest-common-divisor '(polynomial polynomial)
	   (lambda (p1 p2) (tag (gcd-poly p1 p2))))
  (put 'reduce '(polynomial polynomial) reduce-poly)
  'done)
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))

(install-polynomial-package)
